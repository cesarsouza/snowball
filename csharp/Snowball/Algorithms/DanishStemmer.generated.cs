// This file was generated automatically by the Snowball to C# compiler

#pragma warning disable 0164
#pragma warning disable 0162

namespace Snowball
{
    using System;
    using System.Text;
    
    ///<summary>
    ///  This class was automatically generated by a Snowball to Java compiler 
    ///  It implements the stemming algorithm defined by a snowball script.
    ///</summary>
    /// 
    [System.CodeDom.Compiler.GeneratedCode("Snowball", "0.0.0")]
    public partial class DanishStemmer : SnowballStemmer
    {
        private int I_x;
        private int I_p1;
        private StringBuilder S_ch = new StringBuilder();

        private static int[] g_v = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 128 };

        private static int[] g_s_ending = { 239, 254, 42, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 };

        private readonly Among[] a_0;
        private readonly Among[] a_1;
        private readonly Among[] a_2;

        public DanishStemmer()
        {
            a_0 = new[] 
            {
                new Among(UTF16("hed"), -1, 1),
                new Among(UTF16("ethed"), 0, 1),
                new Among(UTF16("ered"), -1, 1),
                new Among(UTF16("e"), -1, 1),
                new Among(UTF16("erede"), 3, 1),
                new Among(UTF16("ende"), 3, 1),
                new Among(UTF16("erende"), 5, 1),
                new Among(UTF16("ene"), 3, 1),
                new Among(UTF16("erne"), 3, 1),
                new Among(UTF16("ere"), 3, 1),
                new Among(UTF16("en"), -1, 1),
                new Among(UTF16("heden"), 10, 1),
                new Among(UTF16("eren"), 10, 1),
                new Among(UTF16("er"), -1, 1),
                new Among(UTF16("heder"), 13, 1),
                new Among(UTF16("erer"), 13, 1),
                new Among(UTF16("s"), -1, 2),
                new Among(UTF16("heds"), 16, 1),
                new Among(UTF16("es"), 16, 1),
                new Among(UTF16("endes"), 18, 1),
                new Among(UTF16("erendes"), 19, 1),
                new Among(UTF16("enes"), 18, 1),
                new Among(UTF16("ernes"), 18, 1),
                new Among(UTF16("eres"), 18, 1),
                new Among(UTF16("ens"), 16, 1),
                new Among(UTF16("hedens"), 24, 1),
                new Among(UTF16("erens"), 24, 1),
                new Among(UTF16("ers"), 16, 1),
                new Among(UTF16("ets"), 16, 1),
                new Among(UTF16("erets"), 28, 1),
                new Among(UTF16("et"), -1, 1),
                new Among(UTF16("eret"), 30, 1)
            };

            a_1 = new[] 
            {
                new Among(UTF16("gd"), -1, -1),
                new Among(UTF16("dt"), -1, -1),
                new Among(UTF16("gt"), -1, -1),
                new Among(UTF16("kt"), -1, -1)
            };

            a_2 = new[] 
            {
                new Among(UTF16("ig"), -1, 1),
                new Among(UTF16("lig"), 0, 1),
                new Among(UTF16("elig"), 1, 1),
                new Among(UTF16("els"), -1, 1),
                new Among(UTF16("l\u00C3\u00B8st"), -1, 2)
            };

        }



        private bool r_mark_regions()
        {
            int v_1;
            int v_2;
            // (, line 29
            I_p1 = limit;
            // test, line 33
            v_1 = cursor;
            // (, line 33
            // hop, line 33

            {
                int c = cursor + 3;
                if (0 > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            // setmark x, line 33
            I_x = cursor;
            cursor = v_1;
            while (true) 
            {
                // goto, line 34
                v_2 = cursor;
                if (!(in_grouping(g_v, 97, 248)))
                {
                    goto lab0;
                }
                cursor = v_2;
                break;
            lab0: 
                cursor = v_2;
                if (cursor >= limit)
                {
                    return false;
                }
                cursor++;
            }
            while (true) 
            {
                // gopast, line 34
                if (!(out_grouping(g_v, 97, 248)))
                {
                    goto lab1;
                }
                break;
            lab1: 
                if (cursor >= limit)
                {
                    return false;
                }
                cursor++;
            }
            // setmark p1, line 34
            I_p1 = cursor;
            // try, line 35
            // (, line 35
            if (!(I_p1 < I_x))
            {
                goto lab2;
            }
            I_p1 = I_x;
        lab2: 

            return true;
        }

        private bool r_main_suffix()
        {
            int among_var;
            int v_1;
            int v_2;
            // (, line 40
            // setlimit, line 41
            v_1 = limit - cursor;
            // tomark, line 41
            if (cursor < I_p1)
            {
                return false;
            }
            cursor = I_p1;
            v_2 = limit_backward;
            limit_backward = cursor;
            cursor = limit - v_1;
            // (, line 41
            // [, line 41
            ket = cursor;
            // substring, line 41
            among_var = find_among_b(a_0);
            if (among_var == 0)
            {
                limit_backward = v_2;
                return false;
            }
            // ], line 41
            bra = cursor;
            limit_backward = v_2;
            switch (among_var) 
            {
                case 0:
                    break;
                case 1:
                    // (, line 48
                    // delete, line 48
                    slice_del();
                    break;
                case 2:
                    // (, line 50
                    if (!(in_grouping_b(g_s_ending, 97, 229)))
                    {
                        return false;
                    }
                    // delete, line 50
                    slice_del();
                    break;
            }

            return true;
        }

        private bool r_consonant_pair()
        {
            int v_1;
            int v_2;
            int v_3;
            // (, line 54
            // test, line 55
            v_1 = limit - cursor;
            // (, line 55
            // setlimit, line 56
            v_2 = limit - cursor;
            // tomark, line 56
            if (cursor < I_p1)
            {
                return false;
            }
            cursor = I_p1;
            v_3 = limit_backward;
            limit_backward = cursor;
            cursor = limit - v_2;
            // (, line 56
            // [, line 56
            ket = cursor;
            // substring, line 56
            if (find_among_b(a_1) == 0)
            {
                limit_backward = v_3;
                return false;
            }
            // ], line 56
            bra = cursor;
            limit_backward = v_3;
            cursor = limit - v_1;
            // next, line 62
            if (cursor <= limit_backward)
            {
                return false;
            }
            cursor--;
            // ], line 62
            bra = cursor;
            // delete, line 62
            slice_del();

            return true;
        }

        private bool r_other_suffix()
        {
            int among_var;
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            // (, line 65
            // do, line 66
            v_1 = limit - cursor;
            // (, line 66
            // [, line 66
            ket = cursor;
            // literal, line 66
            if (!(eq_s_b(UTF16("st"))))
            {
                goto lab0;
            }
            // ], line 66
            bra = cursor;
            // literal, line 66
            if (!(eq_s_b(UTF16("ig"))))
            {
                goto lab0;
            }
            // delete, line 66
            slice_del();
        lab0: 
            cursor = limit - v_1;
            // setlimit, line 67
            v_2 = limit - cursor;
            // tomark, line 67
            if (cursor < I_p1)
            {
                return false;
            }
            cursor = I_p1;
            v_3 = limit_backward;
            limit_backward = cursor;
            cursor = limit - v_2;
            // (, line 67
            // [, line 67
            ket = cursor;
            // substring, line 67
            among_var = find_among_b(a_2);
            if (among_var == 0)
            {
                limit_backward = v_3;
                return false;
            }
            // ], line 67
            bra = cursor;
            limit_backward = v_3;
            switch (among_var) 
            {
                case 0:
                    break;
                case 1:
                    // (, line 70
                    // delete, line 70
                    slice_del();
                    // do, line 70
                    v_4 = limit - cursor;
                    // call consonant_pair, line 70
                    if (!r_consonant_pair())
                    {
                        goto lab1;
                    }
                lab1: 
                    cursor = limit - v_4;
                    break;
                case 2:
                    // (, line 72
                    // <-, line 72
                    slice_from(UTF16("l\u00C3\u00B8s"));
                    break;
            }

            return true;
        }

        private bool r_undouble()
        {
            int v_1;
            int v_2;
            // (, line 75
            // setlimit, line 76
            v_1 = limit - cursor;
            // tomark, line 76
            if (cursor < I_p1)
            {
                return false;
            }
            cursor = I_p1;
            v_2 = limit_backward;
            limit_backward = cursor;
            cursor = limit - v_1;
            // (, line 76
            // [, line 76
            ket = cursor;
            if (!(out_grouping_b(g_v, 97, 248)))
            {
                limit_backward = v_2;
                return false;
            }
            // ], line 76
            bra = cursor;
            // -> ch, line 76
            S_ch = slice_to(S_ch);
            limit_backward = v_2;
            // name ch, line 77
            if (!(eq_s_b(S_ch)))
            {
                return false;
            }
            // delete, line 78
            slice_del();

            return true;
        }

        private bool stem()
        {
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            int v_5;
            // (, line 82
            // do, line 84
            v_1 = cursor;
            // call mark_regions, line 84
            if (!r_mark_regions())
            {
                goto lab0;
            }
        lab0: 
            cursor = v_1;
            // backwards, line 85
            limit_backward = cursor; cursor = limit;
            // (, line 85
            // do, line 86
            v_2 = limit - cursor;
            // call main_suffix, line 86
            if (!r_main_suffix())
            {
                goto lab1;
            }
        lab1: 
            cursor = limit - v_2;
            // do, line 87
            v_3 = limit - cursor;
            // call consonant_pair, line 87
            if (!r_consonant_pair())
            {
                goto lab2;
            }
        lab2: 
            cursor = limit - v_3;
            // do, line 88
            v_4 = limit - cursor;
            // call other_suffix, line 88
            if (!r_other_suffix())
            {
                goto lab3;
            }
        lab3: 
            cursor = limit - v_4;
            // do, line 89
            v_5 = limit - cursor;
            // call undouble, line 89
            if (!r_undouble())
            {
                goto lab4;
            }
        lab4: 
            cursor = limit - v_5;
            cursor = limit_backward;

            return true;
        }

        protected override bool Process()
        {
            return this.stem();
        }

    }
}

